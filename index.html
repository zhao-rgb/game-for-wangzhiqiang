<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>王志强 · 兄弟地狱挑战（Bugfix Final）</title>
<style>
  :root{--pink:#e91e63;--pink2:#ff80ab;--ok:#69f0ae;--bad:#ef5350;}
  html,body{height:100%}
  body{margin:0;background:#0b0b0b;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,PingFang SC}
  h1,h2{color:var(--pink2);text-shadow:0 0 14px rgba(255,128,171,.55);margin:.6rem 0 .3rem}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:12px}
  .menu{position:relative;z-index:10;background:rgba(255,255,255,.06);border:2px solid var(--pink2);border-radius:16px;padding:14px 16px;max-width:900px}
  .btn{padding:10px 16px;border:0;border-radius:999px;background:linear-gradient(45deg,var(--pink),var(--pink2));color:#fff;cursor:pointer;box-shadow:0 6px 18px rgba(0,0,0,.35)}
  .btn:disabled{opacity:.5;cursor:not-allowed}
  .hidden{display:none!important}
  .card{background:rgba(255,255,255,.06);border:2px solid var(--pink2);border-radius:14px;padding:10px 14px;width:920px;max-width:94vw}
  canvas{background:#141414;border-radius:12px}
  .center{display:flex;justify-content:center;align-items:center}
</style>
</head>
<body>
<div class="wrap">
  <h1>王志强 · 兄弟地狱挑战 · 7关 + 难度选择</h1>
  <div class="menu" id="menu">
    <div style="opacity:.9;margin-bottom:8px">跑酷 / 弹幕 / 反转音游 / 打地鼠 / 诡异解谜 / 坦克大战 / Taunt 结算</div>
    <div class="center" style="gap:12px;flex-wrap:wrap">
      <button class="btn" id="btnEasy">简单</button>
      <button class="btn" id="btnNormal">普通</button>
      <button class="btn" id="btnHard">困难</button>
    </div>
  </div>

  <div id="hud" class="hidden"></div>

  <!-- stage1 跑酷 -->
  <section id="s1" class="card hidden">
    <h2>第一关：高难跑酷（Rage Run）</h2>
    <div style="opacity:.85">空格/点击=跳跃；完成目标距离即过关</div>
    <div class="center"><canvas id="run" width="760" height="230"></canvas></div>
    <div class="center" style="margin-top:8px"><button id="r1" class="btn">重试本关</button></div>
  </section>

  <!-- stage2 弹幕 -->
  <section id="s2" class="card hidden">
    <h2>第二关：极限弹幕（Bullet Hell）</h2>
    <div style="opacity:.85">WASD/方向键移动；坚持指定时间不被命中（随机弹幕）</div>
    <div class="center"><canvas id="hell" width="560" height="420"></canvas></div>
    <div class="center" style="margin-top:8px"><button id="r2" class="btn hidden">重试本关</button></div>
  </section>

  <!-- stage3 反转音游 -->
  <section id="s3" class="card hidden">
    <h2>第三关：音游反转（提示是假的）</h2>
    <div style="opacity:.85">看到“按 X”，你必须按与提示<b>相反</b>的方向；连续 N 次过关。</div>
    <div id="rr-hint" style="opacity:.85;margin-top:4px"></div>
    <div id="rr-note" style="font-size:68px;line-height:1.1;margin:14px 0 6px;">按 →</div>
    <div style="opacity:.8">可用键：← → ↑ ↓（支持 WASD）</div>
    <div class="center" style="margin-top:8px"><button id="r3" class="btn hidden">重试本关</button></div>
  </section>

  <!-- stage4 打地鼠 -->
  <section id="s4" class="card hidden">
    <h2>第四关：经典打地鼠</h2>
    <div class="center" style="gap:10px;flex-direction:column">
      <div id="moleHud" style="opacity:.85"></div>
      <div id="moleGrid" style="display:grid;grid-template-columns:repeat(4,100px);grid-gap:10px;"></div>
    </div>
    <div class="center" style="margin-top:8px"><button id="r4" class="btn hidden">重试本关</button></div>
  </section>

  <!-- stage5 诡异解谜（原版占位，简单按钮通过） -->
  <section id="s5" class="card hidden">
    <h2>第五关：诡异解谜</h2>
    <div style="opacity:.85">只要你够细心，这一关不难：找出<b>粉色</b>按钮并点击。</div>
    <div class="center" style="gap:10px;flex-wrap:wrap;margin-top:10px" id="weirdBtns"></div>
    <div class="center" style="margin-top:8px"><button id="r5" class="btn hidden">重试本关</button></div>
  </section>

  <!-- stage6 坦克 -->
  <section id="s6" class="card hidden">
    <h2>第六关：坦克大战</h2>
    <div style="opacity:.85">WASD/方向键移动；空格开火；击毁所有敌人过关（本关恒定最大难度）</div>
    <div class="center"><canvas id="tank" width="720" height="420"></canvas></div>
    <div class="center" style="margin-top:8px"><button id="r6" class="btn">重试本关</button></div>
  </section>

  <!-- stage7 taunt -->
  <section id="s7" class="card hidden">
    <h2>结算</h2>
    <div id="taunt" style="font-size:28px;margin:10px 0 14px"></div>
    <div class="center" style="gap:10px"><button id="again" class="btn">再来一把</button></div>
  </section>
</div>

<script>
/* ================== 全局与切换 ================== */
let difficulty='normal';
let cfg={};
const hud = document.getElementById('hud');
function setDifficulty(lv){
  difficulty=lv;
  if(lv==='easy'){ cfg={
    runTarget:500, runSpeed:3.0, jumpV:-9.5, gap:[160,210],
    hellTime:10, hellSpeed:1.8, hellSpawn:28, hellLimit:150,
    rrNeed:8, rrTimeout:1600,
    moleTime:25, moleNeed:10, moleInterval:[600,900]
  }; }
  else if(lv==='hard'){ cfg={
    runTarget:1100, runSpeed:3.6, jumpV:-8.6, gap:[110,160],
    hellTime:14, hellSpeed:2.4, hellSpawn:34, hellLimit:180,
    rrNeed:12, rrTimeout:1200,
    moleTime:25, moleNeed:16, moleInterval:[420,700]
  }; }
  else { cfg={
    runTarget:800, runSpeed:3.2, jumpV:-9.0, gap:[140,190],
    hellTime:12, hellSpeed:2.1, hellSpawn:30, hellLimit:165,
    rrNeed:10, rrTimeout:1400,
    moleTime:25, moleNeed:12, moleInterval:[520,820]
  }; }
  document.getElementById('menu').classList.add('hidden');
  hud.classList.remove('hidden'); hud.textContent='难度：'+({easy:'简单',normal:'普通',hard:'困难'}[difficulty]);
  go(1); startRun();
}
document.getElementById('btnEasy').onclick=()=>setDifficulty('easy');
document.getElementById('btnNormal').onclick=()=>setDifficulty('normal');
document.getElementById('btnHard').onclick=()=>setDifficulty('hard');

function go(n){
  for(let i=1;i<=7;i++) document.getElementById('s'+i).classList.toggle('hidden', i!==n);
}
function ok(){ console.log('ok'); }
function ng(){ console.log('ng'); }
function tip(t){ console.log(t); }

/* =============== 第一关 跑酷 =============== */
let runAnim=0;
function startRun(){
  const c=document.getElementById('run'), ctx=c.getContext('2d');
  cancelAnimationFrame(runAnim);
  const floor=c.height-28; let dist=0;
  const player={x:70,y:floor-18,w:16,h:18,vy:0,on:true};
  const obs=[]; let lastX=0;
  function addObs(){ lastX+=cfg.gap[0]+Math.random()*(cfg.gap[1]-cfg.gap[0]); obs.push({x:lastX,y:floor-18,w:18,h:18}); }
  for(let i=0;i<9;i++) addObs();
  function jump(){ if(player.on){ player.vy=cfg.jumpV; player.on=false; } }
  c.onclick=jump; window.onkeydown=(e)=>{ if(e.code==='Space') { e.preventDefault(); jump(); } };

  function step(){
    ctx.clearRect(0,0,c.width,c.height);
    // ground
    ctx.fillStyle='#222'; ctx.fillRect(0,floor,c.width,2);
    // move
    player.vy+=0.45; player.y+=player.vy;
    if(player.y>=floor-18){ player.y=floor-18; player.vy=0; player.on=true; }
    ctx.fillStyle='#ffd54f'; ctx.fillRect(player.x,player.y,player.w,player.h);
    obs.forEach(o=>o.x-=cfg.runSpeed);
    if(obs[0].x<-40){ obs.shift(); addObs(); }
    ctx.fillStyle='#ff80ab'; obs.forEach(o=>ctx.fillRect(o.x,o.y,o.w,o.h));
    // collide
    for(const o of obs){
      if(player.x<o.x+o.w && player.x+player.w>o.x && player.y<o.y+o.h && player.y+player.h>o.y){
        cancelAnimationFrame(runAnim); document.getElementById('r1').onclick=startRun; return;
      }
    }
    dist+=cfg.runSpeed; ctx.fillStyle='#fff'; ctx.fillText('目标: '+cfg.runTarget+'  距离:'+Math.floor(dist), 10,16);
    if(dist>=cfg.runTarget){ cancelAnimationFrame(runAnim); go(2); startHell(); return; }
    runAnim=requestAnimationFrame(step);
  }
  step();
}
document.getElementById('r1').onclick=startRun;

/* =============== 第二关 弹幕（稳定版） =============== */
let hellAnim=0;
function startHell(){
  const c=document.getElementById('hell'), ctx=c.getContext('2d');
  cancelAnimationFrame(hellAnim);
  document.getElementById('r2').classList.add('hidden');

  const P={x:c.width*0.5,y:c.height*0.8,r:7};
  const bullets=[]; const MAX=cfg.hellLimit; const V=cfg.hellSpeed;
  const spawnPerS=cfg.hellSpawn;
  let leftMs=cfg.hellTime*1000;
  const keys={};
  const onKD=(e)=>{ keys[e.key]=true; if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','Space','Spacebar'].includes(e.key)) e.preventDefault(); };
  const onKU=(e)=>{ keys[e.key]=false; };
  window.addEventListener('keydown',onKD,{passive:false});
  window.addEventListener('keyup',onKU);

  let last=performance.now(), quota=0;
  function spawnEdge(){
    if(bullets.length>=MAX) return;
    const side=Math.floor(Math.random()*4);
    let x=0,y=0,vx=0,vy=0,sp=V*0.9;
    if(side===0){x=0;y=Math.random()*c.height;vx=sp;vy=(Math.random()-.5)*sp*0.7;}
    if(side===1){x=c.width;y=Math.random()*c.height;vx=-sp;vy=(Math.random()-.5)*sp*0.7;}
    if(side===2){y=0;x=Math.random()*c.width;vy=sp;vx=(Math.random()-.5)*sp*0.7;}
    if(side===3){y=c.height;x=Math.random()*c.width;vy=-sp;vx=(Math.random()-.5)*sp*0.7;}
    bullets.push({x,y,vx,vy});
  }
  function spawnRing(){
    if(bullets.length>=MAX-12) return;
    const cx=Math.random()*c.width, cy=Math.random()*c.height, hole=Math.random()*Math.PI*2;
    const n=Math.max(8, Math.floor(cfg.hellSpawn/2));
    for(let i=0;i<n;i++){ const ang=i*(Math.PI*2/n); if(Math.abs(ang-hole)<0.25) continue;
      bullets.push({x:cx,y:cy,vx:Math.cos(ang)*V,vy:Math.sin(ang)*V}); }
  }
  function cleanup(){ cancelAnimationFrame(hellAnim); window.removeEventListener('keydown',onKD); window.removeEventListener('keyup',onKU); }
  function win(){ cleanup(); go(3); startRR(); }
  function fail(){ cleanup(); document.getElementById('r2').classList.remove('hidden'); }

  function step(now){
    const dt=Math.min(50, now-last); last=now; leftMs-=dt;
    quota += spawnPerS*dt/1000;
    while(quota>=1){ quota-=1; (Math.random()<0.55?spawnEdge:spawnRing)(); }
    // move P
    let dx=(keys['ArrowRight']||keys['d']?1:0)-(keys['ArrowLeft']||keys['a']?1:0);
    let dy=(keys['ArrowDown']||keys['s']?1:0)-(keys['ArrowUp']||keys['w']?1:0);
    if(dx||dy){ const len=Math.hypot(dx,dy)||1; P.x+=dx/len*2.2; P.y+=dy/len*2.2; }
    P.x=Math.max(8,Math.min(c.width-8,P.x)); P.y=Math.max(8,Math.min(c.height-8,P.y));
    // bullets
    for(const b of bullets){ b.x+=b.vx; b.y+=b.vy; }
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if(b.x<-20||b.y<-20||b.x>c.width+20||b.y>c.height+20){ bullets.splice(i,1); continue; }
      if(Math.hypot(b.x-P.x,b.y-P.y) < P.r+2){ fail(); return; }
    }
    // draw
    ctx.clearRect(0,0,c.width,c.height);
    ctx.fillStyle='#fff'; ctx.fillText('剩余: '+Math.ceil(leftMs/1000)+'s',10,16);
    ctx.fillStyle='#ff80ab'; bullets.forEach(b=>ctx.fillRect(b.x-2,b.y-2,4,4));
    ctx.fillStyle='#4caf50'; ctx.beginPath(); ctx.arc(P.x,P.y,P.r,0,Math.PI*2); ctx.fill();
    if(leftMs<=0){ win(); return; }
    hellAnim=requestAnimationFrame(step);
  }
  hellAnim=requestAnimationFrame(step);
}
document.getElementById('r2').onclick=startHell;

/* =============== 第三关 反转音游（稳态：按错也继续） =============== */
let rrAlive=false, rrTimer=0;
function startRR(){
  const hint=document.getElementById('rr-hint'), note=document.getElementById('rr-note');
  rrAlive=false; if(rrTimer) clearTimeout(rrTimer); document.getElementById('r3').classList.add('hidden');
  const need=cfg.rrNeed, timeoutMs=cfg.rrTimeout;
  const showKeys=['←','→','↑','↓']; const toCode={'←':'ArrowLeft','→':'ArrowRight','↑':'ArrowUp','↓':'ArrowDown'};
  const opp={'ArrowLeft':'ArrowRight','ArrowRight':'ArrowLeft','ArrowUp':'ArrowDown','ArrowDown':'ArrowUp'};
  const wasd={'a':'ArrowLeft','d':'ArrowRight','w':'ArrowUp','s':'ArrowDown'};
  let streak=0, expected=null, deadline=0;

  function setPrompt(t,c){ note.textContent='按 '+t; note.style.color=c||'#fff'; }
  function flash(ok){ note.style.transition='transform .12s'; note.style.transform=ok?'scale(1.06)':'scale(.92)'; note.style.color=ok?'#69f0ae':'#ef5350'; setTimeout(()=>{ note.style.transform='none'; note.style.color='#fff'; }, 120); }
  function paint(){ const left=Math.max(0,deadline-performance.now()); hint.innerHTML=`进度：<b>${streak}/${need}</b>　剩余：<b>${Math.ceil(left/100)/10}s</b>`; }

  function next(){
    if(!rrAlive) return;
    const show=showKeys[Math.floor(Math.random()*4)];
    expected=opp[toCode[show]]; setPrompt(show); deadline=performance.now()+timeoutMs; paint();
    if(rrTimer) clearTimeout(rrTimer); rrTimer=setTimeout(()=>answer('TIME'), timeoutMs+20);
  }
  function answer(code){
    if(!rrAlive) return;
    if(rrTimer){ clearTimeout(rrTimer); rrTimer=0; }
    const ok=(code!=='TIME') && (code===expected); flash(ok);
    if(ok){ streak++; if(streak>=need){ stop(); go(4); startMole(); return; } }
    else { streak=Math.max(0, streak-1); }
    setTimeout(next, 160);
  }

  const onKD=(e)=>{
    let code=e.code; if(wasd[e.key]) code=wasd[e.key];
    if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','Space','Spacebar'].includes(e.key)) e.preventDefault();
    if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(code)) answer(code);
  };
  function stop(){ rrAlive=false; window.removeEventListener('keydown',onKD); if(rrTimer) clearTimeout(rrTimer); document.getElementById('r3').classList.remove('hidden'); }
  document.getElementById('r3').onclick=()=>{ stop(); startRR(); };
  window.addEventListener('keydown',onKD,{passive:false}); rrAlive=true; next();
}

/* =============== 第四关 打地鼠（简洁稳定） =============== */
let moleTimer=0, moleAlive=false;
function startMole(){
  const grid=document.getElementById('moleGrid'), hud=document.getElementById('moleHud'); grid.innerHTML=''; hud.textContent='';
  const N=16; for(let i=0;i<N;i++){ const b=document.createElement('button'); b.textContent=''; b.style.width='100px'; b.style.height='100px'; b.style.borderRadius='10px'; b.style.border='0'; b.style.background='#222'; grid.appendChild(b); }
  const cells=[...grid.children]; let score=0, need=cfg.moleNeed, time=cfg.moleTime;
  function spawn(){
    if(!moleAlive) return;
    const i=Math.floor(Math.random()*N), el=cells[i];
    if(el.textContent) return; el.textContent='🐹';
    el.onclick=()=>{ score++; el.textContent=''; el.onclick=null; };
    setTimeout(()=>{ if(el.textContent){ el.textContent=''; el.onclick=null; } }, Math.random()*(cfg.moleInterval[1]-cfg.moleInterval[0])+cfg.moleInterval[0]);
  }
  function tick(){
    hud.innerHTML=`分数：<b>${score}/${need}</b>　时间：<b>${time}s</b>`;
    if(--time<0){ finish(); }
  }
  function finish(){ moleAlive=false; clearInterval(moleTimer); clearInterval(ti); if(score>=need){ go(5); startWeird(); } else { document.getElementById('r4').classList.remove('hidden'); } }
  moleAlive=true; moleTimer=setInterval(spawn, 600); const ti=setInterval(tick,1000); tick();
  document.getElementById('r4').onclick=()=>{ clearInterval(moleTimer); clearInterval(ti); startMole(); };
}

/* =============== 第五关 诡异解谜（找粉色按钮） =============== */
function startWeird(){
  const box=document.getElementById('weirdBtns'); box.innerHTML='';
  const n=18, right=Math.floor(Math.random()*n);
  for(let i=0;i<n;i++){
    const b=document.createElement('button'); b.className='btn'; b.style.background=i===right?'linear-gradient(45deg,#ff80ab,#ff4081)':'#333'; b.style.border='1px solid #222'; b.textContent=i===right?'点我！':'诱饵';
    b.onclick=()=>{ if(i===right){ go(6); startTank(); } else { b.disabled=true; } };
    box.appendChild(b);
  }
  document.getElementById('r5').classList.add('hidden');
}

/* =============== 第六关 坦克大战（恒定最大难度 + BFS） =============== */
let tankAnim=0;
function startTank(){
  const c=document.getElementById('tank'), ctx=c.getContext('2d'); ctx.font="14px system-ui";
  cancelAnimationFrame(tankAnim);
  const keys={}; const onKD=(e)=>{ keys[e.key]=true; if([' ','Spacebar','Space','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) e.preventDefault(); }; const onKU=(e)=>{ keys[e.key]=false; };
  document.addEventListener('keydown',onKD,{passive:false}); document.addEventListener('keyup',onKU);

  const TS=20, COLS=Math.floor(c.width/TS), ROWS=Math.floor(c.height/TS);
  const T0=0,TW=1,TC=2; const map=Array.from({length:ROWS},()=>Array(COLS).fill(0)); const crateHP={};
  const set=(r,k,v)=>{ if(r>=0&&k>=0&&r<ROWS&&k<COLS){ map[r][k]=v; if(v!==TC) delete crateHP[r+','+k]; } };
  const get=(r,k)=> (r<0||k<0||r>=ROWS||k>=COLS)?TW:map[r][k];
  const w2c=(x,y)=>[Math.floor(y/TS),Math.floor(x/TS)]; const c2w=(r,k)=>({x:k*TS+TS/2,y:r*TS+TS/2});
  (function gen(){
    for(let r=0;r<ROWS;r++){ set(r,0,TW); set(r,COLS-1,TW); }
    for(let k=0;k<COLS;k++){ set(0,k,TW); set(ROWS-1,k,TW); }
    const cols=[7, Math.floor(COLS/2), COLS-8]; cols.forEach(cc=>{ for(let r=2;r<ROWS-2;r++){ if(r%5===0) continue; set(r,cc,TW);} });
    const rows=[Math.floor(ROWS/2)-3, Math.floor(ROWS/2)+3]; rows.forEach(rr=>{ for(let k=2;k<COLS-2;k++){ if(k%6===0) continue; set(rr,k,TW);} });
    let crates=18; while(crates--){ const r=2+Math.floor(Math.random()*(ROWS-4)), k=2+Math.floor(Math.random()*(COLS-4)); if(get(r,k)===T0){ set(r,k,TC); crateHP[r+','+k]=(Math.random()<0.4?2:1); } }
  })();

  function Tank(x,y,enemy=false){ return {x,y,dir:0,speed:2.6,enemy,cd:0,stuck:0,path:null}; }
  function free(){ let x=60,y=c.height-60; for(let t=0;t<80;t++){ const [r,k]=w2c(x,y); if(get(r,k)===T0) break; x=60+Math.random()*(c.width-120); y=60+Math.random()*(c.height-120);} return {x,y}; }
  const p0=free(); const player=Tank(p0.x,p0.y,false); let lives=1, grace=60, shield=0, triple=0;
  const enemies=[]; for(let i=0;i<4;i++){ const s=free(); const e=Tank(s.x,s.y,true); e.cd=50; enemies.push(e); }
  const bullets=[]; function fire(t,spread){ if(t.cd>0) return; const a=t.dir+(Math.random()*spread-(spread||0)/2), sp=4.8; bullets.push({x:t.x,y:t.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,fromEnemy:t.enemy,life:240}); if(!t.enemy&&triple>0){ const a1=a+.18,a2=a-.18; bullets.push({x:t.x,y:t.y,vx:Math.cos(a1)*sp,vy:Math.sin(a1)*sp,fromEnemy:false,life:240}); bullets.push({x:t.x,y:t.y,vx:Math.cos(a2)*sp,vy:Math.sin(a2)*sp,fromEnemy:false,life:240}); } t.cd=t.enemy?40:18; }

  function solid(x,y,w,h){ const pts=[[x,y],[x+w,y],[x,y+h],[x+w,y+h]]; for(const [px,py] of pts){ const [r,k]=w2c(px,py); const t=get(r,k); if(t===TW||t===TC) return true; } return false; }
  function move(t,dx,dy){ const sp=t.speed; let nx=t.x+dx*sp, ny=t.y; if(!solid(nx-12,ny-9,24,18)) t.x=nx; nx=t.x; ny=t.y+dy*sp; if(!solid(nx-12,ny-9,24,18)) t.y=ny; t.x=Math.max(12,Math.min(t.x,c.width-12)); t.y=Math.max(9,Math.min(t.y,c.height-9)); }
  function los(ax,ay,bx,by){ const steps=22; for(let i=1;i<=steps;i++){ const x=ax+(bx-ax)*i/steps,y=ay+(by-ay)*i/steps; const [r,k]=w2c(x,y), t=get(r,k); if(t===TW||t===TC) return false; } return true; }
  function bfs(fr,fk,tr,tk){ const key=(r,k)=>r+','+k; const q=[[fr,fk]], prev=new Map(), seen=new Set([key(fr,fk)]); const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; while(q.length){ const [r,k]=q.shift(); if(r===tr&&k===tk) break; for(const [dr,dk] of dirs){ const nr=r+dr,nk=k+dk,kk=key(nr,nk); if(nr<0||nk<0||nr>=ROWS||nk>=COLS) continue; if(get(nr,nk)!==T0) continue; if(!seen.has(kk)){ seen.add(kk); prev.set(kk,[r,k]); q.push([nr,nk]); } } } let cur=[tr,tk], kk=key(cur[0],cur[1]); if(!prev.has(kk)) return null; while(true){ const p=prev.get(kk); if(!p) return null; if(p[0]===fr&&p[1]===fk) return cur; kk=key(p[0],p[1]); cur=p; } }

  function update(){
    // player
    let dx=(keys['ArrowRight']||keys['d']?1:0)-(keys['ArrowLeft']||keys['a']?1:0);
    let dy=(keys['ArrowDown']||keys['s']?1:0)-(keys['ArrowUp']||keys['w']?1:0);
    if(dx||dy){ const len=Math.hypot(dx,dy)||1; player.dir=Math.atan2(dy,dx); move(player,dx/len,dy/len); }
    if(keys[' ']||keys['Spacebar']||keys['Space']) fire(player,0.06);
    if(player.cd>0) player.cd--; if(grace>0) grace--;

    // enemies
    enemies.forEach(e=>{
      const [pr,pk]=w2c(player.x,player.y), [er,ek]=w2c(e.x,e.y);
      if(!e.path || e.stuck>24){ const nx=bfs(er,ek,pr,pk); e.path=nx?[nx[0],nx[1]]:null; e.stuck=0; }
      let mx=0,my=0; if(e.path){ const t=c2w(e.path[0],e.path[1]); const vx=t.x-e.x,vy=t.y-e.y,len=Math.hypot(vx,vy)||1; mx=vx/len*e.speed*.9; my=vy/len*e.speed*.9; if(Math.hypot(vx,vy)<6) e.path=null; } else { mx=(Math.random()-.5)*e.speed; my=(Math.random()-.5)*e.speed; }
      const ox=e.x,oy=e.y; move(e,mx,my); if(Math.hypot(e.x-ox,e.y-oy)<.05) e.stuck++; else e.stuck=0;
      e.dir=Math.atan2(player.y-e.y,player.x-e.x);
      if(e.cd>0) e.cd--; if(los(e.x,e.y,player.x,player.y)&&Math.random()<0.12) fire(e,0.12); else if(Math.random()<0.025) fire(e,0.25);
    });

    // bullets
    bullets.forEach(b=>{ b.x+=b.vx; b.y+=b.vy; b.life--; const [r,k]=w2c(b.x,b.y); const t=get(r,k); if(t===TW){ b.dead=true; } else if(t===TC){ b.dead=true; const id=r+','+k; crateHP[id]=(crateHP[id]||1)-1; if(crateHP[id]<=0) set(r,k,T0); } });
    for(const b of bullets){
      if(b.dead||b.life<=0) continue;
      if(!b.fromEnemy){ enemies.forEach(e=>{ if(!e.dead&&Math.hypot(e.x-b.x,e.y-b.y)<14){ e.dead=true; b.dead=true; } }); }
      else{ if(Math.hypot(player.x-b.x,player.y-b.y)<12){ if(grace<=0){ b.dead=true; if(--lives<=0){ return over(false); } else { grace=60; } } else b.dead=true; } }
      if(b.x<0||b.y<0||b.x>c.width||b.y>c.height) b.dead=true;
    }
    for(let i=enemies.length-1;i>=0;i--) if(enemies[i].dead) enemies.splice(i,1);
    for(let i=0;i<bullets.length;i++) if(bullets[i].dead||bullets[i].life<=0) { bullets.splice(i,1); i--; }
    if(enemies.length===0) return over(true);

    // draw
    ctx.clearRect(0,0,c.width,c.height);
    for(let r=0;r<ROWS;r++) for(let k=0;k<COLS;k++){ const t=map[r][k]; if(t===TW){ ctx.fillStyle='#1e1e1e'; ctx.fillRect(k*TS,r*TS,TS-1,TS-1); } if(t===TC){ ctx.fillStyle='#6d4c41'; ctx.fillRect(k*TS+2,r*TS+2,TS-4,TS-4); } }
    ctx.fillStyle='#fff'; ctx.fillText('生命:'+ '❤'.repeat(lives),8,16);
    ctx.fillStyle='#fff'; bullets.forEach(b=>ctx.fillRect(b.x-2,b.y-2,4,4));
    enemies.forEach(e=>{ ctx.save(); ctx.translate(e.x,e.y); ctx.rotate(e.dir); ctx.fillStyle='#e57373'; ctx.fillRect(-12,-9,24,18); ctx.fillStyle='#ffcdd2'; ctx.fillRect(0,-3,16,6); ctx.restore(); });
    ctx.save(); ctx.translate(player.x,player.y); ctx.rotate(player.dir); ctx.fillStyle='#64b5f6'; ctx.fillRect(-12,-9,24,18); ctx.fillStyle='#bbdefb'; ctx.fillRect(0,-3,16,6); ctx.restore();
    if(grace>0){ ctx.fillStyle='rgba(76,175,80,0.35)'; ctx.beginPath(); ctx.arc(player.x,player.y,16,0,Math.PI*2); ctx.fill(); }
    tankAnim=requestAnimationFrame(update);
  }
  function cleanup(){ cancelAnimationFrame(tankAnim); document.removeEventListener('keydown',onKD); document.removeEventListener('keyup',onKU); }
  function over(win){ cleanup(); go(7); document.getElementById('taunt').innerHTML = win ? '王志强，你竟然通关了？<br>外号：人肉背板' : '被击中，失败'; }
  update();
}
document.getElementById('r6').onclick=startTank;

/* =============== 结算 =============== */
document.getElementById('again').onclick=()=>location.reload();
</script>
</body>
</html>
