<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>兄弟闯关 · 修复版</title>
<style>
  :root{--pink:#e91e63;--pink2:#ff80ab;--bg:#0b0b0b;--panel:#151515;--ok:#69f0ae;--bad:#ef5350;}
  html,body{height:100%}
  body{margin:0;background:#000;color:#fff;font-family:system-ui,-apple-system,Segoe UI,Roboto,PingFang SC;}
  .wrap{min-height:100%;display:flex;flex-direction:column;align-items:center;gap:14px}
  h1,h2{color:var(--pink2);text-shadow:0 0 14px rgba(255,128,171,.5);margin:.6rem 0 .3rem}
  .card{background:rgba(255,255,255,.06);border:2px solid var(--pink2);border-radius:14px;padding:10px 14px}
  .btn{padding:10px 16px;border:0;border-radius:999px;background:linear-gradient(45deg,var(--pink),var(--pink2));color:#fff;cursor:pointer}
  .btn:disabled{opacity:.6;cursor:not-allowed}
  .center{display:flex;justify-content:center;align-items:center}
  .hidden{display:none!important}
  canvas{background:#141414;border-radius:12px}
  .fine{color:var(--ok)} .warn{color:var(--bad)}
</style>
</head>
<body>
<div class="wrap">
  <h1>王志强 · 兄弟闯关</h1>

  <!-- 难度菜单 -->
  <div id="menu" class="card" style="max-width:740px">
    <h2>选择难度</h2>
    <p>（说明：除“坦克大战”始终为<strong>最大难度</strong>外，其它关卡会按难度调整参数）</p>
    <div style="display:flex;gap:10px;flex-wrap:wrap">
      <button class="btn" onclick="setDifficulty('easy')">简单</button>
      <button class="btn" onclick="setDifficulty('normal')">普通</button>
      <button class="btn" onclick="setDifficulty('hard')">困难</button>
    </div>
  </div>

  <!-- 关卡容器 -->
  <div id="stages" class="hidden" style="width:900px;max-width:94vw">
    <div id="hud" style="margin-bottom:8px;opacity:.85"></div>

    <!-- 1 跑酷 -->
    <section id="stage1" class="card">
      <h2>第一关：跑酷</h2>
      <div style="opacity:.85">空格/点击=跳跃；达到目标距离即过关</div>
      <div class="center"><canvas id="run" width="720" height="220"></canvas></div>
      <div class="center" style="gap:10px;margin-top:8px">
        <button id="retry1" class="btn">重试本关</button>
      </div>
    </section>

    <!-- 2 弹幕（稳定版） -->
    <section id="stage2" class="card hidden">
      <h2>第二关：极限弹幕（Bullet Hell）</h2>
      <div style="opacity:.85">WASD/方向键移动；坚持指定时间不被命中</div>
      <div class="center"><canvas id="bh" width="560" height="420"></canvas></div>
      <div class="center" style="gap:10px;margin-top:8px">
        <button id="retry2" class="btn">重试本关</button>
      </div>
    </section>

    <!-- 3 音游反转（修复） -->
    <section id="stage3" class="card hidden">
      <h2>第三关：音游反转（提示是假的）</h2>
      <div style="opacity:.85">看到“按X”，你必须按 <b>与提示相反</b> 的方向。连续答对次数达标即过关。</div>
      <div id="rr-info" style="margin:.4rem 0;opacity:.85"></div>
      <div id="rr-prompt" style="font-size:64px;line-height:1.1;margin:14px 0 6px;">按 →</div>
      <div style="opacity:.8">可用键：← → ↑ ↓（支持 WASD）</div>
      <div class="center" style="gap:10px;margin-top:8px">
        <button id="retry3" class="btn">重试本关</button>
      </div>
    </section>

    <!-- 4 打地鼠（经典） -->
    <section id="stage4" class="card hidden">
      <h2>第四关：经典打地鼠</h2>
      <div style="opacity:.85">在限定时间内打中足够的地鼠</div>
      <div id="mole-wrap" class="center" style="flex-direction:column;gap:8px">
        <div id="mole-grid" style="display:grid;grid-template-columns:repeat(4,90px);grid-gap:10px"></div>
      </div>
      <div class="center" style="gap:10px;margin-top:8px">
        <button id="retry4" class="btn">重试本关</button>
      </div>
    </section>

    <!-- 5 简单拼图 -->
    <section id="stage5" class="card hidden">
      <h2>第五关：拼图</h2>
      <div style="opacity:.85">点击两块交换位置，拼完整图</div>
      <div id="puzzle" class="center" style="gap:6px;flex-wrap:wrap"></div>
      <div class="center" style="gap:10px;margin-top:8px">
        <button id="retry5" class="btn">重试本关</button>
      </div>
    </section>

    <!-- 6 坦克（最大难度 + BFS） -->
    <section id="stage6" class="card hidden">
      <h2>第六关：坦克大战</h2>
      <div style="opacity:.85">WASD/方向键移动，空格开火；击毁所有敌人过关（本关恒定最大难度）</div>
      <div class="center"><canvas id="tank" width="720" height="420"></canvas></div>
      <div class="center" style="gap:10px;margin-top:8px">
        <button id="retry6" class="btn">重试本关</button>
      </div>
    </section>

    <div class="center" style="margin:12px 0"><button id="restartAll" class="btn">重新开始</button></div>
  </div>
</div>

<script>
let difficulty='normal';
let gameConfig={};
function setDifficulty(level){
  difficulty=level;
  // 其它关卡按难度调整；坦克关在代码内部恒定最大难度
  if(level==='easy'){
    gameConfig={
      runTarget:400, runSpeed:3.0, runGap:[160,200], jumpV:-9.5,
      bhTime:8, bhSpawn:22, bhSpeed:1.6, bhLimit:130,
      rrNeed:6, rrTimeout:1700,
      moleTime:20, moleNeed:8, moleInterval:[700,1000],
      puzzleSize:3
    };
  }else if(level==='hard'){
    gameConfig={
      runTarget:1200, runSpeed:3.6, runGap:[110,150], jumpV:-8.4,
      bhTime:14, bhSpawn:34, bhSpeed:2.3, bhLimit:170,
      rrNeed:12, rrTimeout:1200,
      moleTime:25, moleNeed:16, moleInterval:[420,700],
      puzzleSize:4
    };
  }else{ // normal
    gameConfig={
      runTarget:800, runSpeed:3.2, runGap:[140,180], jumpV:-8.9,
      bhTime:10, bhSpawn:28, bhSpeed:1.9, bhLimit:150,
      rrNeed:9, rrTimeout:1500,
      moleTime:22, moleNeed:12, moleInterval:[520,820],
      puzzleSize:3
    };
  }
  document.getElementById('menu').classList.add('hidden');
  document.getElementById('stages').classList.remove('hidden');
  document.getElementById('hud').textContent = '难度：'+({easy:'简单',normal:'普通',hard:'困难'}[difficulty]||'普通');
  startRun();
}

/* 工具：切换关卡 */
function showStage(n){
  for(let i=1;i<=6;i++){
    document.getElementById('stage'+i).classList.toggle('hidden', i!==n);
  }
}

/* ========= 第一关：跑酷 ========= */
let runAnim=0;
function startRun(){
  showStage(1);
  const c=document.getElementById('run'),ctx=c.getContext('2d');
  cancelAnimationFrame(runAnim);
  const floor = c.height-30;
  let player={x:60,y:floor-16,w:16,h:16,vy:0,on:true};
  let dist=0, target=gameConfig.runTarget, speed=gameConfig.runSpeed;
  let obs=[]; let lastX=0;
  function addObs(){
    const gap = rand(gameConfig.runGap[0], gameConfig.runGap[1]);
    lastX += gap;
    obs.push({x:lastX,y:floor-20,w:18,h:20});
  }
  for(let i=0;i<8;i++) addObs();
  function jump(){ if(player.on){ player.vy=gameConfig.jumpV; player.on=false; }}
  c.onclick=jump; window.onkeyup=(e)=>{ if(e.code==='Space') jump(); };

  function step(){
    ctx.clearRect(0,0,c.width,c.height);
    // ground
    ctx.fillStyle='#222'; ctx.fillRect(0,floor,c.width,2);
    // player
    player.vy += 0.45; player.y += player.vy;
    if(player.y>=floor-16){ player.y=floor-16; player.vy=0; player.on=true; }
    ctx.fillStyle='#ffd54f'; ctx.fillRect(player.x,player.y,player.w,player.h);
    // obs move
    obs.forEach(o=>o.x-=speed); if(obs[0].x<-40){ obs.shift(); addObs(); }
    ctx.fillStyle='#ff80ab'; obs.forEach(o=>ctx.fillRect(o.x,o.y,o.w,o.h));
    // collide
    for(const o of obs){
      if(rectHit(player,o)){ failRun(); return; }
    }
    dist+=speed; ctx.fillStyle='#fff'; ctx.fillText('距离:'+Math.floor(dist), 10,16);
    if(dist>=target){ okRun(); return; }
    runAnim=requestAnimationFrame(step);
  }
  function okRun(){ cancelAnimationFrame(runAnim); showStage(2); startBH(); }
  function failRun(){ cancelAnimationFrame(runAnim); document.getElementById('retry1').onclick=startRun; }
  step();
}
function rectHit(a,b){ return a.x<b.x+b.w&&a.x+a.w>b.x&&a.y<b.y+b.h&&a.y+a.h>b.y; }
function rand(a,b){ return a+Math.random()*(b-a); }
document.getElementById('retry1').onclick=startRun;

/* ========= 第二关：弹幕（稳定 rAF 驱动） ========= */
let bhAnim=0;
function startBH(){
  showStage(2);
  const c=document.getElementById('bh'),ctx=c.getContext('2d');
  cancelAnimationFrame(bhAnim);
  const player={x:c.width*0.5,y:c.height*0.8,r:7};
  const bullets=[]; const LIMIT=gameConfig.bhLimit;
  const spawnPerS = gameConfig.bhSpawn; const speed=gameConfig.bhSpeed;
  let leftMs = gameConfig.bhTime*1000;
  const keys={};
  const onKD=(e)=>{ keys[e.key]=true; if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','Space','Spacebar'].includes(e.key)) e.preventDefault(); };
  const onKU=(e)=>{ keys[e.key]=false; };
  window.addEventListener('keydown',onKD,{passive:false}); window.addEventListener('keyup',onKU);

  let last=performance.now(), spawnAcc=0;
  function step(now){
    const dt = Math.min(50, now-last); last=now; leftMs-=dt;
    // spawn quota
    spawnAcc += spawnPerS * dt/1000;
    while(spawnAcc>=1 && bullets.length<LIMIT){
      spawnAcc-=1;
      const edge = Math.floor(Math.random()*4);
      let x=0,y=0,ang=0;
      if(edge===0){ x=Math.random()*c.width; y=-5; }
      if(edge===1){ x=c.width+5; y=Math.random()*c.height; }
      if(edge===2){ x=Math.random()*c.width; y=c.height+5; }
      if(edge===3){ x=-5; y=Math.random()*c.height; }
      ang = Math.atan2(player.y-y, player.x-x) + (Math.random()-.5)*0.6;
      bullets.push({x,y,vx:Math.cos(ang)*speed,vy:Math.sin(ang)*speed});
    }
    // move player
    let dx=(keys['ArrowRight']||keys['d']?1:0)-(keys['ArrowLeft']||keys['a']?1:0);
    let dy=(keys['ArrowDown']||keys['s']?1:0)-(keys['ArrowUp']||keys['w']?1:0);
    if(dx||dy){ const len=Math.hypot(dx,dy)||1; player.x+=dx/len*2.2; player.y+=dy/len*2.2; }
    player.x=Math.max(8,Math.min(c.width-8,player.x)); player.y=Math.max(8,Math.min(c.height-8,player.y));
    // move bullets
    for(const b of bullets){ b.x+=b.vx; b.y+=b.vy; }
    for(let i=bullets.length-1;i>=0;i--){
      const b=bullets[i];
      if(b.x<-10||b.y<-10||b.x>c.width+10||b.y>c.height+10){ bullets.splice(i,1); continue; }
      if( Math.hypot(b.x-player.x,b.y-player.y) < player.r+2 ){ cleanup(); document.getElementById('retry2').onclick=startBH; return; }
    }
    // draw
    ctx.clearRect(0,0,c.width,c.height);
    ctx.fillStyle='#fff'; bullets.forEach(b=>ctx.fillRect(b.x-2,b.y-2,4,4));
    ctx.fillStyle='#4caf50'; ctx.beginPath(); ctx.arc(player.x,player.y,player.r,0,Math.PI*2); ctx.fill();
    ctx.fillStyle='#fff'; ctx.fillText('剩余:'+Math.ceil(leftMs/1000)+'s',10,16);
    if(leftMs<=0){ cleanup(); showStage(3); startRR(); return; }
    bhAnim=requestAnimationFrame(step);
  }
  function cleanup(){ cancelAnimationFrame(bhAnim); window.removeEventListener('keydown',onKD); window.removeEventListener('keyup',onKU); }
  step(last);
}
document.getElementById('retry2').onclick=startBH;

/* ========= 第三关：音游反转（修复：按错也继续） ========= */
let rrAlive=false, rrTimer=0;
function startRR(){
  showStage(3);
  rrAlive=false; if(rrTimer) clearTimeout(rrTimer);
  const info=document.getElementById('rr-info'); const prompt=document.getElementById('rr-prompt');
  const need = gameConfig.rrNeed; const timeoutMs = gameConfig.rrTimeout;
  const keys = {'←':'ArrowLeft','→':'ArrowRight','↑':'ArrowUp','↓':'ArrowDown'};
  const opp  = {'ArrowLeft':'ArrowRight','ArrowRight':'ArrowLeft','ArrowUp':'ArrowDown','ArrowDown':'ArrowUp'};
  const wasd = {'a':'ArrowLeft','d':'ArrowRight','w':'ArrowUp','s':'ArrowDown'};
  let streak=0, expected=null, deadline=0;
  function setPrompt(t){ prompt.textContent='按 '+t; prompt.style.color='#fff'; }
  function flash(ok){ prompt.style.transition='transform .12s'; prompt.style.transform=ok?'scale(1.06)':'scale(.92)'; prompt.style.color=ok?'#69f0ae':'#ef5350'; setTimeout(()=>{prompt.style.transform='none';prompt.style.color='#fff';},120); }
  function paint(){ const left=Math.max(0,deadline-performance.now()); info.innerHTML=`进度：<b>${streak}/${need}</b>　剩余：<b>${Math.ceil(left/100)/10}s</b>`; }
  function next(){
    if(!rrAlive) return;
    const show = ['←','→','↑','↓'][Math.floor(Math.random()*4)];
    expected = opp[keys[show]]; setPrompt(show);
    deadline = performance.now()+timeoutMs; paint();
    if(rrTimer) clearTimeout(rrTimer); rrTimer=setTimeout(()=>answer('TIME'), timeoutMs+20);
  }
  function answer(code){
    if(!rrAlive) return;
    if(rrTimer) { clearTimeout(rrTimer); rrTimer=0; }
    const hit = (code!=='TIME') && (code===expected);
    flash(hit);
    if(hit){ streak++; } else { streak = Math.max(0, streak-1); } // 错误不锁死，扣一格
    paint();
    if(streak>=need){ stop(); showStage(4); startMole(); return; }
    setTimeout(next, 160); // 继续出题
  }
  const onKD=(e)=>{
    let code=e.code;
    if(wasd[e.key]) code=wasd[e.key];
    if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown',' ','Space','Spacebar'].includes(e.key)) e.preventDefault();
    if(['ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(code)) answer(code);
  };
  function stop(){ rrAlive=false; window.removeEventListener('keydown',onKD); if(rrTimer) clearTimeout(rrTimer); }
  window.addEventListener('keydown', onKD, {passive:false});
  document.getElementById('retry3').onclick=()=>{ stop(); startRR(); };
  rrAlive=true; next();
}

/* ========= 第四关：打地鼠 ========= */
let moleTimer=0, moleAlive=false;
function startMole(){
  showStage(4);
  const grid=document.getElementById('mole-grid'); grid.innerHTML='';
  const N=16; for(let i=0;i<N;i++){ const b=document.createElement('button'); b.textContent=''; b.style.width='90px'; b.style.height='90px'; b.style.borderRadius='10px'; b.style.border='0'; b.style.background='#222'; grid.appendChild(b); }
  const cells=[...grid.children];
  let score=0, need=gameConfig.moleNeed, timeLeft=gameConfig.moleTime;
  function paint(){ grid.previousElementSibling?.remove(); }
  function flash(i,hit){
    const el=cells[i]; el.style.background=hit?'#69f0ae':'#ef5350'; setTimeout(()=>{ el.style.background='#222'; },150);
  }
  function spawn(){
    if(!moleAlive) return;
    const i = Math.floor(Math.random()*N); const el=cells[i];
    el.textContent='🐹'; const started=Date.now();
    const clear=()=>{ el.textContent=''; el.onclick=null; };
    el.onclick=()=>{ score++; flash(i,true); clear(); }; 
    setTimeout(()=>{ if(el.textContent){ flash(i,false); clear(); } }, rand(gameConfig.moleInterval[0],gameConfig.moleInterval[1]));
  }
  function tick(){
    document.getElementById('mole-wrap').querySelector('div').insertAdjacentHTML('afterbegin', `<div id="mole-hud" style="margin-bottom:4px">分数：<b>${score}/${need}</b>　时间：<b>${timeLeft}s</b></div>`);
  }
  function loop(){
    if(!moleAlive) return;
    document.getElementById('mole-hud')?.remove();
    tick();
    spawn();
  }
  moleAlive=true;
  moleTimer=setInterval(loop, 700);
  const endInt=setInterval(()=>{ if(--timeLeft<=0){ clearInterval(endInt); finish(); } },1000);
  function finish(){
    clearInterval(moleTimer); moleAlive=false;
    document.getElementById('retry4').onclick=startMole;
    if(score>=need){ showStage(5); startPuzzle(); }
  }
}
document.getElementById('retry4').onclick=startMole;

/* ========= 第五关：拼图 ========= */
function startPuzzle(){
  showStage(5);
  const root=document.getElementById('puzzle'); root.innerHTML='';
  const N=gameConfig.puzzleSize; const size=96;
  const img='https://picsum.photos/288?random=8';
  const order=[...Array(N*N).keys()].sort(()=>Math.random()-.5);
  let first=null;
  for(let i=0;i<N*N;i++){
    const d=document.createElement('div'); d.style.width=size+'px'; d.style.height=size+'px'; d.style.backgroundImage=`url(${img})`; d.style.backgroundSize=`${N*size}px ${N*size}px`; d.style.backgroundPosition=`-${(order[i]%N)*size}px -${Math.floor(order[i]/N)*size}px`; d.style.boxShadow='0 2px 6px rgba(0,0,0,.45)'; d.style.cursor='pointer'; d.dataset.idx=order[i]; d.onclick=()=>{
      if(!first){ first=d; d.style.outline='3px solid #ffd54f'; } else if(first===d){ d.style.outline=''; first=null; } else {
        const bi=first.dataset.idx, bj=d.dataset.idx, bp=first.style.backgroundPosition; first.dataset.idx=bj; d.dataset.idx=bi; first.style.backgroundPosition=d.style.backgroundPosition; d.style.backgroundPosition=bp; first.style.outline=''; first=null; check();
      }
    }; root.appendChild(d);
  }
  function check(){ if([...root.children].every((c,i)=>Number(c.dataset.idx)===i)){ setTimeout(()=>{ showStage(6); startTank(); }, 300); } }
  document.getElementById('retry5').onclick=startPuzzle;
}

/* ========= 第六关：坦克大战（恒定最大难度 + BFS） ========= */
let tankAnim=0;
function startTank(){
  showStage(6);
  const c=document.getElementById('tank'),ctx=c.getContext('2d'); ctx.font="14px system-ui";
  if(document.activeElement) try{document.activeElement.blur();}catch{}
  cancelAnimationFrame(tankAnim);
  const keys={}; const onKD=(e)=>{ keys[e.key]=true; if([' ','Spacebar','Space','ArrowLeft','ArrowRight','ArrowUp','ArrowDown'].includes(e.key)) e.preventDefault(); }; const onKU=(e)=>{ keys[e.key]=false; };
  document.addEventListener('keydown',onKD,{passive:false}); document.addEventListener('keyup',onKU);

  // 地图
  const TS=20, COLS=Math.floor(c.width/TS), ROWS=Math.floor(c.height/TS);
  const T_EMPTY=0, T_WALL=1, T_CRATE=2;
  const map=Array.from({length:ROWS},()=>Array(COLS).fill(0)); const crateHP={};
  const setTile=(r,c,v)=>{ if(r>=0&&c>=0&&r<ROWS&&c<COLS){ map[r][c]=v; if(v!==T_CRATE) delete crateHP[r+','+c]; } };
  const getTile=(r,c)=> (r<0||c<0||r>=ROWS||c>=COLS)?T_WALL:map[r][c];
  const worldToCell=(x,y)=>[Math.floor(y/TS),Math.floor(x/TS)];
  const cellCenter=(r,c)=>({x:c*TS+TS/2,y:r*TS+TS/2});
  function gen(){
    for(let r=0;r<ROWS;r++){ setTile(r,0,T_WALL); setTile(r,COLS-1,T_WALL); }
    for(let c0=0;c0<COLS;c0++){ setTile(0,c0,T_WALL); setTile(ROWS-1,c0,T_WALL); }
    const cols=[7, Math.floor(COLS/2), COLS-8];
    cols.forEach(cc=>{ for(let r=2;r<ROWS-2;r++){ if(r%5===0) continue; setTile(r,cc,T_WALL);} });
    const rows=[Math.floor(ROWS/2)-3, Math.floor(ROWS/2)+3];
    rows.forEach(rr=>{ for(let c1=2;c1<COLS-2;c1++){ if(c1%6===0) continue; setTile(rr,c1,T_WALL);} });
    let crate=18; while(crate--){ const r=2+Math.floor(Math.random()*(ROWS-4)), cc=2+Math.floor(Math.random()*(COLS-4)); if(getTile(r,cc)===T_EMPTY){ setTile(r,cc,T_CRATE); crateHP[r+','+cc]=(Math.random()<0.4?2:1); } }
  }
  gen();

  // 道具（低频）
  const items=[]; const itemTypes=['shield','triple','speed']; let itemClock=0;
  function spawnItem(){ for(let t=0;t<60;t++){ const r=1+Math.floor(Math.random()*(ROWS-2)), cc=1+Math.floor(Math.random()*(COLS-2)); if(getTile(r,cc)===T_EMPTY){ items.push({x:cc*TS+TS/2,y:r*TS+TS/2,type:itemTypes[Math.floor(Math.random()*itemTypes.length)],life:560}); break;} } }

  // 坦克/子弹
  function Tank(x,y,enemy=false){ return {x,y,dir:0,speed:2.6,enemy,cd:0,path:null,stuck:0}; }
  function spawnFree(){ let x=60,y=c.height-60; for(let t=0;t<80;t++){ const [r,cc]=worldToCell(x,y); if(getTile(r,cc)===T_EMPTY) break; x=60+Math.random()*(c.width-120); y=60+Math.random()*(c.height-120);} return {x,y}; }
  const ppos=spawnFree(); const player=Tank(ppos.x,ppos.y,false); let lives=1, grace=60, shield=0, triple=0, speedBuf=0;
  const enemies=[]; for(let i=0;i<4;i++){ const s=spawnFree(); const e=Tank(s.x,s.y,true); e.speed=2.6; e.cd=60; enemies.push(e); }
  const bullets=[];
  function fire(t,spread=0){ if(t.cd>0) return; const a=t.dir+(Math.random()*spread-spread/2), sp=4.8; bullets.push({x:t.x,y:t.y,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp,fromEnemy:t.enemy,life:240}); if(!t.enemy&&triple>0){ const a1=a+.18,a2=a-.18; bullets.push({x:t.x,y:t.y,vx:Math.cos(a1)*sp,vy:Math.sin(a1)*sp,fromEnemy:false,life:240}); bullets.push({x:t.x,y:t.y,vx:Math.cos(a2)*sp,vy:Math.sin(a2)*sp,fromEnemy:false,life:240}); } t.cd=t.enemy?40:18; }
  function rectHits(x,y,w,h){ const pts=[[x,y],[x+w,y],[x,y+h],[x+w,y+h]]; for(const [px,py] of pts){ const [r,c0]=worldToCell(px,py); const t=getTile(r,c0); if(t===T_WALL||t===T_CRATE) return true; } return false; }
  function moveTank(t,dx,dy){ const sp=t.speed*(t===player&&speedBuf>0?1.35:1); let nx=t.x+dx*sp, ny=t.y; if(!rectHits(nx-12,ny-9,24,18)) t.x=nx; nx=t.x; ny=t.y+dy*sp; if(!rectHits(nx-12,ny-9,24,18)) t.y=ny; t.x=Math.max(12,Math.min(t.x,c.width-12)); t.y=Math.max(9,Math.min(t.y,c.height-9)); }
  function hasLOS(ax,ay,bx,by){ const steps=22; for(let i=1;i<=steps;i++){ const x=ax+(bx-ax)*i/steps, y=ay+(by-ay)*i/steps; const [r,c0]=worldToCell(x,y); const t=getTile(r,c0); if(t===T_WALL||t===T_CRATE) return false; } return true; }
  function bfsNext(fr,fc,tr,tc){ const key=(r,c)=>r+','+c; const q=[[fr,fc]]; const prev=new Map(); const seen=new Set([key(fr,fc)]); const dirs=[[1,0],[-1,0],[0,1],[0,-1]]; while(q.length){ const [r,c0]=q.shift(); if(r===tr&&c0===tc) break; for(const [dr,dc] of dirs){ const nr=r+dr,nc=c0+dc,k=key(nr,nc); if(nr<0||nc<0||nr>=ROWS||nc>=COLS) continue; if(getTile(nr,nc)!==T_EMPTY) continue; if(!seen.has(k)){ seen.add(k); prev.set(k,[r,c0]); q.push([nr,nc]); } } } let cur=[tr,tc], k=key(cur[0],cur[1]); if(!prev.has(k)) return null; while(true){ const p=prev.get(k); if(!p) return null; if(p[0]===fr&&p[1]===fc) return cur; k=p[0]+','+p[1]; cur=p; } }

  // 更新
  function update(){
    // 玩家
    let dx=(keys['ArrowRight']||keys['d']?1:0)-(keys['ArrowLeft']||keys['a']?1:0);
    let dy=(keys['ArrowDown']||keys['s']?1:0)-(keys['ArrowUp']||keys['w']?1:0);
    if(dx||dy){ const len=Math.hypot(dx,dy)||1; player.dir=Math.atan2(dy,dx); moveTank(player,dx/len,dy/len); }
    if(keys[' ']||keys['Spacebar']||keys['Space']) fire(player,0.05);
    if(player.cd>0) player.cd--; if(grace>0) grace--; if(shield>0) shield--; if(triple>0) triple--; if(speedBuf>0) speedBuf--;

    // 道具刷新与拾取
    if(++itemClock>560){ itemClock=0; spawnItem(); }
    for(const it of items){ it.life--; if(Math.hypot(player.x-it.x,player.y-it.y)<16){ it.dead=true; if(it.type==='shield') shield=360; if(it.type==='triple') triple=360; if(it.type==='speed') speedBuf=300; } if(it.life<=0) it.dead=true; }
    for(let i=items.length-1;i>=0;i--) if(items[i].dead) items.splice(i,1);

    // 敌人 AI
    enemies.forEach(e=>{
      const [pr,pc]=worldToCell(player.x,player.y), [er,ec]=worldToCell(e.x,e.y);
      if(!e.path || e.stuck>24){ const nx=bfsNext(er,ec,pr,pc); e.path = nx ? [nx[0],nx[1]] : null; e.stuck=0; }
      let mx=0,my=0; if(e.path){ const t=cellCenter(e.path[0],e.path[1]); const vx=t.x-e.x, vy=t.y-e.y, len=Math.hypot(vx,vy)||1; mx=vx/len*e.speed*.9; my=vy/len*e.speed*.9; if(Math.hypot(vx,vy)<6) e.path=null; } else { mx=(Math.random()-.5)*e.speed; my=(Math.random()-.5)*e.speed; }
      const ox=e.x, oy=e.y; moveTank(e,mx,my); if(Math.hypot(e.x-ox,e.y-oy)<.05) e.stuck++; else e.stuck=0;
      e.dir=Math.atan2(player.y-e.y,player.x-e.x);
      if(e.cd>0) e.cd--; if(hasLOS(e.x,e.y,player.x,player.y) && Math.random()<0.12) fire(e,0.12); else if(Math.random()<0.025) fire(e,0.25);
    });

    // 子弹
    bullets.forEach(b=>{ b.x+=b.vx; b.y+=b.vy; b.life--; const [r,cc]=worldToCell(b.x,b.y); const t=getTile(r,cc); if(t===T_WALL){ b.dead=true; } else if(t===T_CRATE){ b.dead=true; const k=r+','+cc; crateHP[k]=(crateHP[k]||1)-1; if(crateHP[k]<=0) setTile(r,cc,T_EMPTY); } });
    for(const b of bullets){
      if(b.dead||b.life<=0) continue;
      if(!b.fromEnemy){ enemies.forEach(e=>{ if(!e.dead&&Math.hypot(e.x-b.x,e.y-b.y)<14){ e.dead=true; b.dead=true; } }); }
      else{ if(Math.hypot(player.x-b.x,player.y-b.y)<12){ if(grace<=0){ b.dead=true; if(shield>0){} else { if(--lives<=0){ return end(false); } else { grace=60; } } } else b.dead=true; } }
      if(b.x<0||b.y<0||b.x>c.width||b.y>c.height) b.dead=true;
    }
    for(let i=enemies.length-1;i>=0;i--) if(enemies[i].dead) enemies.splice(i,1);
    for(let i=bullets.length-1;i>=0;i--) if(bullets[i].dead||bullets[i].life<=0) bullets.splice(i,1);
    if(enemies.length===0) return end(true);

    // 绘制
    ctx.clearRect(0,0,c.width,c.height);
    for(let r=0;r<ROWS;r++) for(let k=0;k<COLS;k++){ const t=map[r][k]; if(t===T_WALL){ ctx.fillStyle='#1e1e1e'; ctx.fillRect(k*TS,r*TS,TS-1,TS-1); } if(t===T_CRATE){ ctx.fillStyle='#6d4c41'; ctx.fillRect(k*TS+2,r*TS+2,TS-4,TS-4); } }
    items.forEach(it=>{ ctx.fillStyle= it.type==='shield'?'#42a5f5': (it.type==='triple'?'#ffb74d':'#66bb6a'); ctx.beginPath(); ctx.arc(it.x,it.y,7,0,Math.PI*2); ctx.fill(); });
    ctx.fillStyle='#fff'; bullets.forEach(b=>ctx.fillRect(b.x-2,b.y-2,4,4));
    enemies.forEach(e=>{ ctx.save(); ctx.translate(e.x,e.y); ctx.rotate(e.dir); ctx.fillStyle='#e57373'; ctx.fillRect(-12,-9,24,18); ctx.fillStyle='#ffcdd2'; ctx.fillRect(0,-3,16,6); ctx.restore(); });
    ctx.save(); ctx.translate(player.x,player.y); ctx.rotate(player.dir); ctx.fillStyle='#64b5f6'; ctx.fillRect(-12,-9,24,18); ctx.fillStyle='#bbdefb'; ctx.fillRect(0,-3,16,6); ctx.restore();
    if(grace>0){ ctx.fillStyle='rgba(76,175,80,0.35)'; ctx.beginPath(); ctx.arc(player.x,player.y,16,0,Math.PI*2); ctx.fill(); }
    if(shield>0){ ctx.strokeStyle='rgba(66,165,245,0.8)'; ctx.lineWidth=3; ctx.beginPath(); ctx.arc(player.x,player.y,18,0,Math.PI*2); ctx.stroke(); }
    ctx.fillStyle='#fff'; ctx.fillText('生命:'+ '❤'.repeat(lives), 8, 16);
    tankAnim=requestAnimationFrame(update);
  }
  function cleanup(){ cancelAnimationFrame(tankAnim); document.removeEventListener('keydown',onKD); document.removeEventListener('keyup',onKU); }
  function end(win){ cleanup(); alert(win?'通关！兄弟你真猛！':'失败：下次再来'); }
  update();
}
document.getElementById('retry6').onclick=startTank;

document.getElementById('restartAll').onclick=()=>{ location.reload(); };
</script>
</body>
</html>
